<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Django 入门篇（快速入门，立刻上手！） # 后端的主要功能是，管理数据库、响应前端的请求。例如用户登录，前端需要携带用户名和密码等信息向后端某个路由发送请求，后端则根据用户名查找数据库，验证密码是否正确，并携带结果响应前端。
后端处理前端HTTP请求的流程可以概括为如下：用户点击某个前端部件，前端通过指定请求路由向后端发送请求内容，后端收到请求之后，寻找匹配该请求路由对应的视图函数，在视图函数中配合数据库对发送而来的请求内容进行处理，然后再向前端发送请求处理的结果信息，前端收到结果信息后对用户进行反馈
Django 是一个由 Python 编写的高级 Web 框架，使用框架进行 Web 开发，能避免重复造轮子，而专注于应用程序的业务逻辑。
环境配置 # 我们可以考虑一个小的问题，现在有不同的项目需要在同一个服务器上运行，项目一需要 Python >= 3.8 的环境，因为其中有一个核心的算法模型只支持 3.8 及其以上的 Python 版本，而项目二需要 Python <= 3.7 的环境，因为其中有一个拓展包并没有随着 Python 版本的更新而进行维护，导致 Python 3.7 及其以上的环境不支持该拓展包的使用，那么我们该怎么处理呢。一个很自然的想法就是，我们对于不同的项目，单独给其配置环境就可以了，将两个项目的环境区别开来，互不影响，这样就可以在同一个服务器上进行不同项目的部署了。
给不同项目单独配置的环境叫做虚拟环境，管理虚拟环境的工具叫做 Conda，Conda的种类有很多，比如Anaconda，miniconda等等，上面这两个 Conda 是常用的 Conda，二者区别在于Anaconda自带了很多数据科学计算的包（该虚拟环境已经安装好了比如 NumPy，Panda等包），而miniconda则是一个空的环境。
相比于直接安装 Python 某个版本，我们更推荐安装 Anaconda 管理虚拟环境（miniconda 也可以，这里以 Anaconda 作为例子）。Python 项目的版本和依赖各有千秋，而使用 Anaconda 能针对项目建立虚拟环境，互不干扰且便于管理。
Anaconda下载地址：
官网： https://www.anaconda.com/ 清华镜像： https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/（选择最新版本即可） 安装步骤中注意勾选添加至环境变量中 安装 Anaconda 后，使用 conda 指令新建一个虚拟环境，用于开发 Django 项目：
注意：请不要创建 python 大等于 3.10 的环境，因为python的版本需要和 Django 的版本需要适配，目前常用的版本是 Django=4."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Django入门篇（修订中...）"><meta property="og:description" content="Django 入门篇（快速入门，立刻上手！） # 后端的主要功能是，管理数据库、响应前端的请求。例如用户登录，前端需要携带用户名和密码等信息向后端某个路由发送请求，后端则根据用户名查找数据库，验证密码是否正确，并携带结果响应前端。
后端处理前端HTTP请求的流程可以概括为如下：用户点击某个前端部件，前端通过指定请求路由向后端发送请求内容，后端收到请求之后，寻找匹配该请求路由对应的视图函数，在视图函数中配合数据库对发送而来的请求内容进行处理，然后再向前端发送请求处理的结果信息，前端收到结果信息后对用户进行反馈
Django 是一个由 Python 编写的高级 Web 框架，使用框架进行 Web 开发，能避免重复造轮子，而专注于应用程序的业务逻辑。
环境配置 # 我们可以考虑一个小的问题，现在有不同的项目需要在同一个服务器上运行，项目一需要 Python >= 3.8 的环境，因为其中有一个核心的算法模型只支持 3.8 及其以上的 Python 版本，而项目二需要 Python <= 3.7 的环境，因为其中有一个拓展包并没有随着 Python 版本的更新而进行维护，导致 Python 3.7 及其以上的环境不支持该拓展包的使用，那么我们该怎么处理呢。一个很自然的想法就是，我们对于不同的项目，单独给其配置环境就可以了，将两个项目的环境区别开来，互不影响，这样就可以在同一个服务器上进行不同项目的部署了。
给不同项目单独配置的环境叫做虚拟环境，管理虚拟环境的工具叫做 Conda，Conda的种类有很多，比如Anaconda，miniconda等等，上面这两个 Conda 是常用的 Conda，二者区别在于Anaconda自带了很多数据科学计算的包（该虚拟环境已经安装好了比如 NumPy，Panda等包），而miniconda则是一个空的环境。
相比于直接安装 Python 某个版本，我们更推荐安装 Anaconda 管理虚拟环境（miniconda 也可以，这里以 Anaconda 作为例子）。Python 项目的版本和依赖各有千秋，而使用 Anaconda 能针对项目建立虚拟环境，互不干扰且便于管理。
Anaconda下载地址：
官网： https://www.anaconda.com/ 清华镜像： https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/（选择最新版本即可） 安装步骤中注意勾选添加至环境变量中 安装 Anaconda 后，使用 conda 指令新建一个虚拟环境，用于开发 Django 项目：
注意：请不要创建 python 大等于 3.10 的环境，因为python的版本需要和 Django 的版本需要适配，目前常用的版本是 Django=4."><meta property="og:type" content="article"><meta property="og:url" content="https://BUAA-GoodBro2021.github.io/SE-Labs/docs/labs/lab02/django_door/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2023-03-14T20:17:36+08:00"><title>Django入门篇（修订中...） | 软件工程基础上机指南</title><link rel=manifest href=/SE-Labs/manifest.json><link rel=icon href=/SE-Labs/favicon.png type=image/x-icon><link rel=stylesheet href=/SE-Labs/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/SE-Labs/flexsearch.min.js></script>
<script defer src=/SE-Labs/en.search.min.6df40ce09760f2aef066110ff29ef7ba2ab4eeb653dda78fb62e8fe0c8ab6521.js integrity="sha256-bfQM4Jdg8q7wZhEP8p73uiq07rZT3aePti6P4MirZSE=" crossorigin=anonymous></script>
<script defer src=/SE-Labs/sw.min.f070c2d3fe61272a24a6ca9a09530ce459448de39ce9b3c07c7e12ee4e7b69a1.js integrity="sha256-8HDC0/5hJyokpsqaCVMM5FlEjeOc6bPAfH4S7k57aaE=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/SE-Labs/><span>软件工程基础上机指南</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Labs</span><ul><li><a href=/SE-Labs/docs/labs/lab01/>Lab01 Git</a><ul><li><a href=/SE-Labs/docs/labs/lab01/git/>Git 简易教程</a></li><li><a href=/SE-Labs/docs/labs/lab01/git_command/>Git 指令全集</a></li></ul></li><li><a href=/SE-Labs/docs/labs/lab02/>Lab02 前后端基础Ⅰ</a><ul><li><a href=/SE-Labs/docs/labs/lab02/frontend_index/>前端实验指南</a></li><li><a href=/SE-Labs/docs/labs/lab02/Example-code/>前端示例代码</a></li><li><a href=/SE-Labs/docs/labs/lab02/backend_index/>后端实验指南</a></li><li><a href=/SE-Labs/docs/labs/lab02/django_door/ class=active>Django入门篇（修订中...）</a></li><li><a href=/SE-Labs/docs/labs/lab02/django_earth/>Django入土篇</a></li></ul></li></ul></li></ul><ul><li><a href=https://github.com/BUAA-GoodBro2021/SE-Labs target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/SE-Labs/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Django入门篇（修订中...）</strong>
<label for=toc-control><img src=/SE-Labs/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#django-入门篇快速入门立刻上手>Django 入门篇（快速入门，立刻上手！）</a><ul><li><a href=#环境配置>环境配置</a></li><li><a href=#新建项目>新建项目</a></li><li><a href=#了解项目结构>了解项目结构</a></li><li><a href=#项目预设置>项目预设置</a><ul><li><a href=#添加-app-信息>添加 APP 信息</a></li><li><a href=#路由分发>路由分发</a></li></ul></li><li><a href=#示例-出版网站>示例 出版网站</a><ul><li><a href=#数据库模型>数据库模型</a></li><li><a href=#注册功能>注册功能</a></li><li><a href=#登录功能>登录功能</a></li><li><a href=#退出登录功能>退出登录功能</a></li></ul></li><li><a href=#sqlite-数据库可视化>sqlite 数据库可视化</a><ul><li><a href=#pycharm-可视化数据库>Pycharm 可视化数据库</a></li><li><a href=#datagrip-可视化数据库>DataGrip 可视化数据库</a></li><li><a href=#使用-mysql>使用 MySQL</a></li></ul></li><li><a href=#postman-测试>Postman 测试</a></li><li><a href=#简单的调试方法>简单的调试方法</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=django-入门篇快速入门立刻上手>Django 入门篇（快速入门，立刻上手！）
<a class=anchor href=#django-%e5%85%a5%e9%97%a8%e7%af%87%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8%e7%ab%8b%e5%88%bb%e4%b8%8a%e6%89%8b>#</a></h1><blockquote class="book-hint info"><p>后端的主要功能是，管理数据库、响应前端的请求。例如用户登录，前端需要携带用户名和密码等信息向后端<strong>某个路由</strong>发送请求，后端则根据用户名查找<strong>数据库</strong>，验证密码是否正确，并携带结果<strong>响应</strong>前端。</p><p><strong>后端处理前端HTTP请求的流程可以概括为如下：用户点击某个前端部件，前端通过指定请求路由向后端发送请求内容，后端收到请求之后，寻找匹配该请求路由对应的视图函数，在视图函数中配合数据库对发送而来的请求内容进行处理，然后再向前端发送请求处理的结果信息，前端收到结果信息后对用户进行反馈</strong></p></blockquote><p><a href=https://www.djangoproject.com/ target=_blank>Django</a> 是一个由 Python 编写的高级 Web 框架，使用框架进行 Web 开发，能避免重复造轮子，而专注于应用程序的业务逻辑。</p><h2 id=环境配置>环境配置
<a class=anchor href=#%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae>#</a></h2><blockquote><p>我们可以考虑一个小的问题，现在有不同的项目需要在同一个服务器上运行，项目一需要 Python >= 3.8 的环境，因为其中有一个核心的算法模型只支持 3.8 及其以上的 Python 版本，而项目二需要 Python &lt;= 3.7 的环境，因为其中有一个拓展包并没有随着 Python 版本的更新而进行维护，导致 Python 3.7 及其以上的环境不支持该拓展包的使用，那么我们该怎么处理呢。一个很自然的想法就是，我们对于不同的项目，单独给其配置环境就可以了，将两个项目的环境区别开来，互不影响，这样就可以在同一个服务器上进行不同项目的部署了。</p></blockquote><p>给不同项目单独配置的环境叫做<strong>虚拟环境</strong>，管理虚拟环境的工具叫做 Conda，Conda的种类有很多，比如Anaconda，miniconda等等，上面这两个 Conda 是常用的 Conda，二者区别在于Anaconda自带了很多数据科学计算的包（该虚拟环境已经安装好了比如 NumPy，Panda等包），而miniconda则是一个空的环境。</p><p>相比于直接安装 Python 某个版本，我们更推荐安装 <a href=https://www.anaconda.com/ target=_blank>Anaconda</a> 管理虚拟环境（miniconda 也可以，这里以 Anaconda 作为例子）。Python 项目的版本和依赖各有千秋，而使用 Anaconda 能针对项目建立虚拟环境，互不干扰且便于管理。</p><p>Anaconda下载地址：</p><ul><li>官网：<a href=https://www.anaconda.com/ target=_blank>
<a href=https://www.anaconda.com/>https://www.anaconda.com/</a></a></li><li>清华镜像：<a href=https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ target=_blank>
<a href=https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/>https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></a>（选择最新版本即可）</li></ul><blockquote class="book-hint warning">安装步骤中注意勾选添加至环境变量中</blockquote><p>安装 Anaconda 后，使用 conda 指令新建一个虚拟环境，用于开发 Django 项目：</p><p>注意：<strong>请不要创建 python 大等于 3.10 的环境</strong>，因为python的版本需要和 Django 的版本需要适配，目前常用的版本是 Django=4.x.x，其主要支持的 python 版本为 3.9。如果创建3.10 以上的版本在接下来的迁移数据库的实验操作中会遇到下面的报错，提示版本不兼容。</p><blockquote><p>django.db.utils.NotSupportedError: deterministic=True requires SQLite 3.8.3 or higher</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>conda create --name django python<span style=color:#f92672>=</span>3.9   <span style=color:#75715e># 虚拟环境名为django，python版本指定3.9</span>
</span></span></code></pre></div><p>进入 django 虚拟环境，如果测试命令行前出现 (django) 说明成功进入虚拟环境：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>conda activate django
</span></span></code></pre></div><details><summary>Conda常用指令</summary><div class=markdown-inner><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>conda info --env        <span style=color:#75715e># 查看所有虚拟环境</span>
</span></span><span style=display:flex><span>conda create --name &lt;name&gt; python<span style=color:#f92672>=</span>&lt;version&gt; <span style=color:#75715e># 新建环境</span>
</span></span><span style=display:flex><span>conda activate &lt;name&gt;   <span style=color:#75715e># 进入虚拟环境</span>
</span></span><span style=display:flex><span>conda deactivate        <span style=color:#75715e># 退出环境</span>
</span></span></code></pre></div></div></details><p>安装 django 依赖：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pip install django
</span></span></code></pre></div><p><strong>当然，如果你不安装 Anaconda，也可以直接通过上面最后一条指令安装 django 依赖。此时选择的是全局环境</strong></p><h2 id=新建项目>新建项目
<a class=anchor href=#%e6%96%b0%e5%bb%ba%e9%a1%b9%e7%9b%ae>#</a></h2><div class=book-tabs><input type=radio class=toggle name=tabs-django_init id=tabs-django_init-0 checked>
<label for=tabs-django_init-0>命令行创建</label><div class="book-tabs-content markdown-inner"><p>在某个文件夹内打开终端，输入下面指令创建 Django 项目：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>django-admin startproject press <span style=color:#75715e># 新建名为 press（出版社）的项目</span>
</span></span></code></pre></div><p>创建成功后，出现了 <code>press</code> 文件夹，在目录下可以看到 <code>press</code> 文件夹和 <code>manage.py</code> 文件，其内容主要是项目运行入口和总配置。</p><p>接下来我们先创建一个 app（应用程序），app 用于实现业务逻辑，包含数据库模型的建立、建立路由和API响应前端的请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>python manage.py startapp publish   <span style=color:#75715e># 新建名为 publish 的 app</span>
</span></span></code></pre></div><p>创建 app 成功后，目录下多出一个文件夹名为 <code>publish</code>，包含 views、models 等文件。先不管项目内容，输入以下命令，让项目跑起来：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>python manage.py runserver
</span></span></code></pre></div><p>运行成功后，将提示运行在 <a href=http://127.0.0.1:8000/ target=_blank>http://127.0.0.1:8000/</a>，浏览器打开即可。</p></div><input type=radio class=toggle name=tabs-django_init id=tabs-django_init-1>
<label for=tabs-django_init-1>Pycharm创建</label><div class="book-tabs-content markdown-inner"><p>如果想使用 Pycharm 来新建项目，以及完成后续的 Django 代码编写，需要使用 Pycharm</p><p>用Pycharm新建项目十分方便，省去了命令行操作，点击导航栏文件处，选择新建项目。</p><p>如下图，如果已新建好 Conda 虚拟环境，请配置已有环境。此处我还选择了新建名为 <code>publish</code> 的 app，将在该 app 中实现业务逻辑，包含数据库模型的建立、建立路由和API响应前端的请求。</p><p><img src=/SE-Labs/images/lab2/pycharm.png alt=pycharm新建项目></p><p>新建成功后，点击右上角运行按钮。运行成功后，将提示运行在 <a href=http://127.0.0.1:8000/ target=_blank>http://127.0.0.1:8000/</a>，浏览器打开即可。</p></div></div><h2 id=了解项目结构>了解项目结构
<a class=anchor href=#%e4%ba%86%e8%a7%a3%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84>#</a></h2><p>经过上述步骤，我们创建了 django 项目，在新建了名为 <code>publish</code> 的 app。</p><p>目录结构如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>press
</span></span><span style=display:flex><span>|-- publish             <span style=color:#75715e># app目录</span>
</span></span><span style=display:flex><span>|   |-- __init__.py     <span style=color:#75715e># python包声明</span>
</span></span><span style=display:flex><span>|   |-- admin.py
</span></span><span style=display:flex><span>|   |-- apps.py         <span style=color:#75715e># app配置文件(一般不用修改)</span>
</span></span><span style=display:flex><span>|   |-- models.py       <span style=color:#75715e># 数据库模型配置(数据库表的创建与更新，很重要)</span>
</span></span><span style=display:flex><span>|   |-- tests.py        <span style=color:#75715e># 测试模块(一般不用修改)</span>
</span></span><span style=display:flex><span>|   <span style=color:#e6db74>`</span>-- views.py        <span style=color:#75715e># 视图编写文件（API-实现业务逻辑，响应前端的请求，很重要）</span>
</span></span><span style=display:flex><span>|-- press
</span></span><span style=display:flex><span>|   |-- __init__.py
</span></span><span style=display:flex><span>|   |-- asgi.py
</span></span><span style=display:flex><span>|   |-- settings.py     <span style=color:#75715e># 项目配置文件(很重要)</span>
</span></span><span style=display:flex><span>|   |-- urls.py         <span style=color:#75715e># 后端路由设置(很重要)</span>
</span></span><span style=display:flex><span>|   <span style=color:#e6db74>`</span>-- wsgi.py         <span style=color:#75715e># uwsgi运行入口(一般不用修改)</span>
</span></span><span style=display:flex><span>|-- manage.py           <span style=color:#75715e># django命令行工具(一般不用修改)</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>-- db.sqlite3          <span style=color:#75715e># 数据库文件</span>
</span></span></code></pre></div><p>看到这里有可能有点模糊，拎几个重点的需要修改的文件出来介绍：</p><ul><li>publish/models.py：数据库模型设置，在这里要建立数据库表项及其属性</li><li>publish/views.py：编写api的文件，在这里要编写和规划所有的请求处理函数。</li><li>press/settings.py：项目总配置文件，在这里实现跨域设置、app信息等</li><li>press/urls.py：后端路由设置，在这里指定后端API的路由，以供前端发送请求</li><li>db.sqlite3：数据库文件，如果 Django 项目不指定自己所用的数据库，那么会默认使用该数据库文件。在此次入门篇教程中，我们对于数据库的操作以及数据的存储都针对的是这个文件。<strong>但是在实际开发中，我们并不会使用该文件，而是会自己指定使用准备好的数据库，并在 settings.py 中进行配置（一般是MySQL，具体操作可以见Django入土篇）</strong></li></ul><h2 id=项目预设置>项目预设置
<a class=anchor href=#%e9%a1%b9%e7%9b%ae%e9%a2%84%e8%ae%be%e7%bd%ae>#</a></h2><h3 id=添加-app-信息>添加 APP 信息
<a class=anchor href=#%e6%b7%bb%e5%8a%a0-app-%e4%bf%a1%e6%81%af>#</a></h3><p>若是在 Pycharm 中创建的项目，在 press/settings.py 中已自动添加好 app 信息，无需再度添加；如果是命令行创建，则需在 settings 文件的 <code>INSTALLED_APPS</code> 中添加 app 名字：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>INSTALLED_APPS <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.contrib.admin&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.contrib.auth&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.contrib.contenttypes&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.contrib.sessions&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.contrib.messages&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.contrib.staticfiles&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;publish&#39;</span>,  <span style=color:#75715e># app name</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>在这里添加 app 的名字，是为了告诉 django 这个 python 包是这个项目的一个 app。</p><h3 id=路由分发>路由分发
<a class=anchor href=#%e8%b7%af%e7%94%b1%e5%88%86%e5%8f%91>#</a></h3><p>一个较大的项目可能需要建立多个app，在其中实现业务逻辑，这样不同 app 全部 api 的路由都在一个文件中（press/urls.py）添加是不合适的。<strong>因此，可以在各 app 下新建 urls.py 文件</strong>，并在总的路由文件中指定包含这些文件。具体操作请看下面：</p><p>首先，在 app（publish目录） 下新建 <code>urls.py</code> 文件，内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># publish/urls.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> django.urls <span style=color:#f92672>import</span> path
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> .views <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>urlpatterns <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#75715e># path(&#39;url_name&#39;, api_name)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 这是一个样例，指定路由名为url_name，对应处理函数为当前app内views.py中的api_name</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>接着在项目配置目录（press目录）的 <code>urls.py</code> 引入上面文件的路由：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># press/urls.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> django.contrib <span style=color:#f92672>import</span> admin
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> django.urls <span style=color:#f92672>import</span> path, include
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>urlpatterns <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    path(<span style=color:#e6db74>&#39;api/admin/&#39;</span>, admin<span style=color:#f92672>.</span>site<span style=color:#f92672>.</span>urls),
</span></span><span style=display:flex><span>    path(<span style=color:#e6db74>&#39;api/publish/&#39;</span>, include((<span style=color:#e6db74>&#39;publish.urls&#39;</span>, <span style=color:#e6db74>&#39;publish&#39;</span>))),
</span></span><span style=display:flex><span>    <span style=color:#75715e># 将各app（如publish）中指定的路由导入到总路由中</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>上述操作实现了将 publish 这个 app 指定的 urls，<strong>全部接到了路由 <code>api/publish/</code> 之后。</strong></p><blockquote><p>处理 URL 请求的过程可以总结于以下的流程：</p><ol><li>Django 从配置文件中根据 ROOT——URLCONF 找到主路由文件；默认情况下，该文件在项目同名目录下的urls.py</li><li>Django 加载 主路由 文件中的 urlpatterns 变量 [很多路由的列表]</li><li>依次匹配 urlpatterns 中的 path ，匹配到第一个合适的中断后续匹配</li><li>匹配成功&ndash;调用对应的视图函数处理请求，返回响应</li><li>匹配失败&ndash;返回404响应</li></ol></blockquote><h2 id=示例-出版网站>示例 出版网站
<a class=anchor href=#%e7%a4%ba%e4%be%8b-%e5%87%ba%e7%89%88%e7%bd%91%e7%ab%99>#</a></h2><p>假设要开发一个出版网站，最基本的是给作者提供注册、登录和退出登录这三个功能。</p><blockquote><p>假设作者的用户名唯一，可作为用户标识</p></blockquote><p>逻辑：</p><ul><li>当前端发来注册请求时，后端验证两次密码是否一致，成功后将信息填入到数据库中；</li><li>当前端发来登录请求时，后端需要拿着用户名到数据库中查询，验证密码是否正确，再返回给前端信息；若登录成功还需存储登录信息；</li><li>当前端发来退出登录请求时，后端需要清空登录信息，并返回结果。</li></ul><h3 id=数据库模型>数据库模型
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%a8%a1%e5%9e%8b>#</a></h3><blockquote><p>什么是模型?</p><ul><li>模型是一个Pyhton类，它是由django.db.models.Model派生出来的子类</li><li>一个模型类代表数据库中的一张数据表</li><li>模型类中每一个类属性都代表数据库中的一个字段</li><li>模型是数据交互的接口，是表示和操作数据库的方式和方法</li></ul></blockquote><p>完成上述逻辑前，我们需要先修改 <code>publish/models.py</code>，添加 <code>author</code> 用户的表项。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># publish/models.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> django.db <span style=color:#f92672>import</span> models
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Author</span>(models<span style=color:#f92672>.</span>Model):
</span></span><span style=display:flex><span>    <span style=color:#75715e># Author表项，含用户名和密码，均为字符串属性，并设置最大长度</span>
</span></span><span style=display:flex><span>    username <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>CharField(<span style=color:#e6db74>&#34;作者名&#34;</span>, max_length<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>    password <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>CharField(<span style=color:#e6db74>&#34;密码&#34;</span>, max_length<span style=color:#f92672>=</span><span style=color:#ae81ff>20</span>)
</span></span></code></pre></div><blockquote><p>这里好像并没有创建 作者id字段，但是后续的部分竟然使用到了，这是为什么呢？因为如果数据库字段中没有手动指定 AutoField (根据 ID 自增长的 IntegerField 字段，通常用于主键ID)字段，则会默认创建一个</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>id <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>AutoField(primary_key<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span></code></pre></div><p><strong>一般都会选择让系统默认创建 id 字段</strong></p></blockquote><p>在修改数据库模型之后，<strong>一定要</strong>生成迁移文件，并应用新的数据库模型。在终端输入以下命令实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>python manage.py makemigrations <span style=color:#75715e># 生成迁移文件</span>
</span></span><span style=display:flex><span>python manage.py migrate        <span style=color:#75715e># 迁移数据库模型</span>
</span></span></code></pre></div><blockquote><p>这里如果遇到报错 django.db.utils.NotSupportedError: deterministic=True requires SQLite 3.8.3 or higher 说明目前你的环境不支持直接使用 django 自己生成的 db.sqlite 数据库文件，这一点也不用担心，我们可以<strong>在settings.py中配置其他数据库（比如MySQL）</strong>，有关如何配置 MySQL数据库可见
<a href=/SE-Labs/docs/labs/lab02/django_door/#sqlite-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8f%af%e8%a7%86%e5%8c%96>sqlite 数据库可视化</a>。这里并没有配置 settings.py 中数据库的使用方式，因此迁移数据库的时候默认直接创建 db.sqlite，此时同学们遇到上述报错那就没有办法只能配置 MySQL再完成后续的操作了。</p></blockquote><blockquote><p>上面这两条指令比较难记住，助教给大家提供了一个脚本，只需要运行该脚本直接执行上述两条指令并同时启动 Django 服务。在与 manage.py 的同级目录下创建 run.py 文件，将该代码复制粘贴至 run.py ，然后使用 python run.py 即可完成三条核心指令的运行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> platform
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>system(<span style=color:#e6db74>&#34;python manage.py makemigrations&#34;</span>)
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>system(<span style=color:#e6db74>&#34;python manage.py migrate&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> platform<span style=color:#f92672>.</span>system() <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;Linux&#34;</span>:
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>system(<span style=color:#e6db74>&#34;python manage.py runserver&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 本地环境，直接运行</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>system(<span style=color:#e6db74>&#34;python manage.py runserver 0.0.0.0:8000 &gt; log.txt &amp; </span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;The backend is running!&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 服务器环境，后台运行</span>
</span></span></code></pre></div><p>但是实际上在 Linux 服务器上运行的时候，我们一般不采用runserver进行启动，而是采用之前我们提到的 wsgi.py 来运行 uwsgi 配合 nginx 完成启动，因为 runserver 启动的服务不支持 HTTPS 的通信，并发能力也不足，无法<strong>配合 nginx 完成反向代理和负载均衡</strong>。这些名词大家不懂也没有关系，在之后的部署实验章节会和大家介绍这些，目前我们都采用 runserver 启动即可。</p></blockquote><p>输入上述命令迁移后运行，可以发现在项目根目录出现了 <code>db.sqlite3</code> 文件。这是一个数据库文件，如何可视化请见后面
<a href=/SE-Labs/docs/labs/lab02/django_door/#sqlite-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8f%af%e8%a7%86%e5%8c%96>sqlite 数据库可视化</a>，你也可以先看可视化部分再回头。</p><details><summary>数据库模型指令介绍</summary><div class=markdown-inner><h4 id=django-的-model-数据类型>Django 的 Model 数据类型
<a class=anchor href=#django-%e7%9a%84-model-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b>#</a></h4><p>我们观察到，我们创建的Author模型实际上是继承了models.Model这里类，models这个包中包含了我们在进行数据库建模的所有需要的语句</p><table><thead><tr><th>数据类型</th><th>说明</th></tr></thead><tbody><tr><td>AutoField</td><td>根据 ID 自增长的 IntegerField 字段，通常用于主键ID</td></tr><tr><td>IntegerField</td><td>32位整数，可自定义选项</td></tr><tr><td>BooleanField</td><td>布尔值(True/False)字段</td></tr><tr><td>CharField</td><td>字符串字段，对小字符串和大字符串都适用；对于大量文本建议使用TextField。必须参数：max_length（字段的最大字符数）</td></tr><tr><td>DateField</td><td>利用 Python 的 datetime.date 实例来表示日期</td></tr><tr><td>DateTimeField</td><td>利用 datetime.datetime 实例表示日期和时间</td></tr><tr><td>EmailField</td><td>带有 email 合法性检测的CharField，默认max_length=75</td></tr><tr><td>TextField</td><td>超大文本字段</td></tr><tr><td>FileField</td><td>文件字段</td></tr><tr><td>ImageField</td><td>继承于FileField，确保是有效图片（建议不明白什么是有效图片的最好还是使用FileField）</td></tr></tbody></table><h4 id=model-数据类型的通用参数>Model 数据类型的通用参数
<a class=anchor href=#model-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e9%80%9a%e7%94%a8%e5%8f%82%e6%95%b0>#</a></h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>null</td><td>是否允许为空值，默认为false</td></tr><tr><td>default</td><td>该属性的默认值</td></tr><tr><td>primary_key</td><td>该属性是否为主键，默认为false</td></tr><tr><td>unique</td><td>该属性的值是否唯一，默认为false</td></tr></tbody></table><h4 id=时间类型的可选参数>时间类型的可选参数
<a class=anchor href=#%e6%97%b6%e9%97%b4%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8f%af%e9%80%89%e5%8f%82%e6%95%b0>#</a></h4><ul><li>DateField.auto_now：设为 <code>True</code> 时，每一次保存对象时，Django 都会自动将该字段的值设置为当前时间。一般用来表示最后修改时间。</li><li>DateField.auto_now_add：设为 <code>True</code> 时，第一次创建对象时，Django 自动将该字段的值设置为当前时间，一般用来表示对象创建时间。</li></ul></div></details><h3 id=注册功能>注册功能
<a class=anchor href=#%e6%b3%a8%e5%86%8c%e5%8a%9f%e8%83%bd>#</a></h3><p>完成一个业务功能的实现，一般分为两步：编写业务逻辑处理函数，指定路由。</p><p>先实现业务逻辑，在 <code>publish/views.py</code> 中编写 API 函数，内容如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># publish/views.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> django.http <span style=color:#f92672>import</span> JsonResponse
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> django.views.decorators.csrf <span style=color:#f92672>import</span> csrf_exempt
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> publish.models <span style=color:#f92672>import</span> Author   <span style=color:#75715e># 引入数据库 Author 对象</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@csrf_exempt</span>    <span style=color:#75715e># 跨域设置</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>register</span>(request):  <span style=color:#75715e># 继承请求类</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> request<span style=color:#f92672>.</span>method <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;POST&#39;</span>:  <span style=color:#75715e># 判断请求方式是否为 POST（此处要求为POST方式）</span>
</span></span><span style=display:flex><span>        username <span style=color:#f92672>=</span> request<span style=color:#f92672>.</span>POST<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;username&#39;</span>)  <span style=color:#75715e># 获取请求体中的请求数据</span>
</span></span><span style=display:flex><span>        password_1 <span style=color:#f92672>=</span> request<span style=color:#f92672>.</span>POST<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;password_1&#39;</span>)
</span></span><span style=display:flex><span>        password_2 <span style=color:#f92672>=</span> request<span style=color:#f92672>.</span>POST<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;password_2&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> password_1 <span style=color:#f92672>!=</span> password_2:    <span style=color:#75715e># 若两次输入的密码不同，则返回错误码errno和描述信息msg</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> JsonResponse({<span style=color:#e6db74>&#39;errno&#39;</span>: <span style=color:#ae81ff>1002</span>, <span style=color:#e6db74>&#39;msg&#39;</span>: <span style=color:#e6db74>&#34;两次输入的密码不同&#34;</span>}) <span style=color:#75715e># 返还给前端处理结果信息</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#75715e># 新建 Author 对象，赋值用户名和密码并保存</span>
</span></span><span style=display:flex><span>            new_author <span style=color:#f92672>=</span> Author(username<span style=color:#f92672>=</span>username, password<span style=color:#f92672>=</span>password_1)
</span></span><span style=display:flex><span>            new_author<span style=color:#f92672>.</span>save()   <span style=color:#75715e># 一定要save才能保存到数据库中</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> JsonResponse({<span style=color:#e6db74>&#39;errno&#39;</span>: <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;msg&#39;</span>: <span style=color:#e6db74>&#34;注册成功&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> JsonResponse({<span style=color:#e6db74>&#39;errno&#39;</span>: <span style=color:#ae81ff>1001</span>, <span style=color:#e6db74>&#39;msg&#39;</span>: <span style=color:#e6db74>&#34;请求方式错误&#34;</span>})
</span></span></code></pre></div><blockquote><p>我们发现好像 Django 对于数据库的操作很轻松（ Springboot 需要写 SQL 语句来操作数据，SQL语句不好写哇）这是因为 Django 对于数据库的操作采用的是ORM框架，那么什么是ORM框架呢？</p><ol><li>ORM框架可以建立模型类和表之间的对于关系，允许我们通过<strong>面向对象</strong>的方式来操作数据库</li><li>ORM框架可以根据涉及的模型类生成数据库中表格</li><li>ORM框架可以通过简单的配置就可以进行数据库的切换</li></ol><p>只需要简简单单的几行面向对象的代码就可以完成大量的增删改查，具体的增删改查在下方有介绍</p></blockquote><p>我们注意到好像这个试图函数前面加了一个 @csrf_exempt 这个装饰器，如果不加这个装饰器会怎么样呢，答案就是这个视图函数返回的 JsonResponse 信息并不能返回到前端，前端会直接报错。为什么呢，其实Django是一个安全性很强的框架，对于每一个视图函数，都会检查是否包含 CSRF 攻击的可能，如果我们前后端是分离的（前后端部署不在一个服务器上，简称跨域），而且并没有做CSRF的处理的话，Django会对前端发送而来的请求进行拦截，这可真麻烦！因此<strong>我们可以给试图函数的上方装一个不进行CSRF检测的装饰器，这样我们就可以不被Django内部的安全系统给拦截了</strong>。</p><p>但是我们会想，给每一个视图函数都加CSRF是不是太累了，能不能直接就把CSRF安全检查直接去了呢？当然可以，我们在 settings.py的中间件中直接把CSRF中间注释掉就OK了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>MIDDLEWARE <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.middleware.security.SecurityMiddleware&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.contrib.sessions.middleware.SessionMiddleware&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.middleware.common.CommonMiddleware&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#75715e># &#39;django.middleware.csrf.CsrfViewMiddleware&#39;,</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.contrib.auth.middleware.AuthenticationMiddleware&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.contrib.messages.middleware.MessageMiddleware&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;django.middleware.clickjacking.XFrameOptionsMiddleware&#39;</span>,
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>但是大家又会思考，我把CSRF这个中间件注释之后，我们前后端分离的web网站，还可以应对 CSRF 攻击吗？当然可以应对呀，我们可以采用 <strong>JWT</strong> 的方式（JSON Web Token）来解决，<strong>后端登录之后，签发一个令牌（token）给前端，之后前端每一个请求都携带这个令牌让后端验证即可，如果令牌错误或者过期要求用户重新登录</strong>，这个大家可以自行去进行深入了解~</p><blockquote class="book-hint info"><p>HTTP八大请求详情可见
<a href=/SE-Labs/docs/else/res/httprequest/>HTTP八大请求</a>，常用GET和POST。</p><ul><li>GET：用于获取资源，请求中不应该包含数据体。</li><li>POST：用于提交数据，数据被包含在请求体中，处理该请求服务器可能会建立或更新资源。</li></ul></blockquote><p><strong>下面是数据库的增删改查操作，很重要！！！！</strong></p><details><summary>Django数据库存取操作</summary><div class=markdown-inner><p>我们以下面这个这个类举例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Book</span>(models<span style=color:#f92672>.</span>Model):
</span></span><span style=display:flex><span>	title <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>CharField(<span style=color:#e6db74>&#39;书名&#39;</span>, max_length<span style=color:#f92672>=</span><span style=color:#ae81ff>50</span>, default<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;&#39;</span>)
</span></span><span style=display:flex><span>    price <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>DecimalField(<span style=color:#e6db74>&#39;定价&#39;</span>, max_digits<span style=color:#f92672>=</span><span style=color:#ae81ff>7</span>, decimal_places<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>,default<span style=color:#f92672>=</span><span style=color:#ae81ff>0.0</span>)
</span></span><span style=display:flex><span>	author <span style=color:#f92672>=</span> models<span style=color:#f92672>.</span>CharField(<span style=color:#e6db74>&#39;作者姓名&#39;</span>,max_length<span style=color:#f92672>=</span><span style=color:#ae81ff>50</span>,default<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;&#39;</span>)
</span></span></code></pre></div><h4 id=增>增
<a class=anchor href=#%e5%a2%9e>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 方法一</span>
</span></span><span style=display:flex><span>book <span style=color:#f92672>=</span> Book()
</span></span><span style=display:flex><span>book<span style=color:#f92672>.</span>title <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;软件工程基础指导&#34;</span>
</span></span><span style=display:flex><span>book<span style=color:#f92672>.</span>author <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;吕云翔&#34;</span>
</span></span><span style=display:flex><span>user<span style=color:#f92672>.</span>save()
</span></span><span style=display:flex><span><span style=color:#75715e># 方法二</span>
</span></span><span style=display:flex><span>book <span style=color:#f92672>=</span> Book(id<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;软件工程基础指导&#34;</span>, author<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;吕云翔&#34;</span>)
</span></span><span style=display:flex><span>book<span style=color:#f92672>.</span>save()
</span></span><span style=display:flex><span><span style=color:#75715e># 方法三</span>
</span></span><span style=display:flex><span>book <span style=color:#f92672>=</span> Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>create(id<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>, title<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;软件工程基础指导&#34;</span>, author<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;吕云翔&#34;</span>)
</span></span></code></pre></div><h4 id=查>查
<a class=anchor href=#%e6%9f%a5>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 查询特定结果（返回一个类的对象）</span>
</span></span><span style=display:flex><span>book <span style=color:#f92672>=</span> Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>get(id<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)	<span style=color:#75715e># 查询 id 为 1 的书</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 查询全部结果（返回一个QuerySet）</span>
</span></span><span style=display:flex><span>books <span style=color:#f92672>=</span> Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>all()		<span style=color:#75715e># 返回数据库所有书</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 筛选多个结果（返回一个QuerySet，不是list，可以通过列表表达式转换成一个列表）</span>
</span></span><span style=display:flex><span>books <span style=color:#f92672>=</span> Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>filter(author<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;吕云翔&#34;</span>)  <span style=color:#75715e># 查询所有吕云翔老师编写的书</span>
</span></span><span style=display:flex><span>books <span style=color:#f92672>=</span> Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>exclude(author<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;吕云翔&#34;</span>)  <span style=color:#75715e># 查询除吕云翔老师编写之外的书</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 进行非等值查询（返回一个QuerySet）</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>1.</span> 模糊查询 __contains
</span></span><span style=display:flex><span>Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>filter(author__contains<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;吕&#39;</span>) <span style=color:#75715e># 查询姓吕的作者编写的书</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>2.</span> 大小关系 __gt __gte __lt __lte
</span></span><span style=display:flex><span>Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>filter(price__gt<span style=color:#f92672>=</span><span style=color:#ae81ff>30.0</span>, author__contains<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;吕&#39;</span>) <span style=color:#75715e># 查询售价大于30元的，且是姓吕的作者编写的书 (filter中由多个查询条件为&#39;与&#39;的关系)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>3.</span> 存在关系 __in
</span></span><span style=display:flex><span>Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>filter(author__in <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;吕云翔&#39;</span>,<span style=color:#e6db74>&#39;周恩申&#39;</span>,<span style=color:#e6db74>&#39;李昊&#39;</span>,<span style=color:#e6db74>&#39;闫思桥&#39;</span>]) 
</span></span><span style=display:flex><span><span style=color:#ae81ff>4.</span> 范围 __range
</span></span><span style=display:flex><span>Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>filter(id__range<span style=color:#f92672>=</span>(<span style=color:#ae81ff>35</span>,<span style=color:#ae81ff>50</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>对于QuerySet类型<span style=color:#960050;background-color:#1e0010>，</span>我们可以进行多次查询操作
</span></span><span style=display:flex><span>Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>filter(price__gt<span style=color:#f92672>=</span><span style=color:#ae81ff>30.0</span>, author__contains<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;吕&#39;</span>)<span style=color:#f92672>.</span>exclude(author<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;吕云翔&#34;</span>)
</span></span></code></pre></div><p>同样的，ORM也支持聚合查询（数据库课程中也会提到），Django 可以采用聚合函数来进行聚合查询，其内部的实现方式也是基于上述介绍的过滤器等查询方法。</p><h4 id=改>改
<a class=anchor href=#%e6%94%b9>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 方法一：查后改后保存</span>
</span></span><span style=display:flex><span>book <span style=color:#f92672>=</span> Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>get(id<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>book<span style=color:#f92672>.</span>author <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;周恩申&#34;</span>
</span></span><span style=display:flex><span>book<span style=color:#f92672>.</span>save()
</span></span><span style=display:flex><span><span style=color:#75715e># 方法二：更新</span>
</span></span><span style=display:flex><span>books <span style=color:#f92672>=</span> Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>filter(author<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;吕云翔&#34;</span>)
</span></span><span style=display:flex><span>books<span style=color:#f92672>.</span>update(author<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;周恩申&#34;</span>)
</span></span></code></pre></div><h4 id=删>删
<a class=anchor href=#%e5%88%a0>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>book <span style=color:#f92672>=</span> Book<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>get(id<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>book<span style=color:#f92672>.</span>delete()
</span></span></code></pre></div></div></details><p>接下来为该 API 指定路由，在 <code>publish/urls.py</code> 中添加：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># publish/urls.py</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> django.urls <span style=color:#f92672>import</span> path
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> .views <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>urlpatterns <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    path(<span style=color:#e6db74>&#39;register&#39;</span>, register),  <span style=color:#75715e># 指定register函数的路由为register</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>由于前面做了路由的 <code>include</code> 设置，因此该 register 对应的路由为 <code>api/publish/register</code>，若项目运行在 8000 端口，则完整的路由为 <a href=http://127.0.0.1:8000/api/publish/register target=_blank>http://127.0.0.1:8000/api/publish/register</a>。</p><p>这样实现后，该 API 详细信息为：</p><ul><li>路由：http://127.0.0.1:8000/api/publish/register</li><li>请求数据：用户名 <code>username</code>，密码 <code>password_1</code>，确认密码 <code>password_2</code></li><li>响应数据：JSON格式，错误码 <code>errno</code> 和描述信息 <code>msg</code></li><li>响应样例：<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;errno&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;msg&#34;</span>: <span style=color:#e6db74>&#34;注册成功&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><blockquote><p>如何测试API在后面
<a href=/SE-Labs/docs/labs/lab02/django_door/#postman-%e6%b5%8b%e8%af%95>Postman测试</a>中介绍，你也可以先看测试部分再回头</p></blockquote><h3 id=登录功能>登录功能
<a class=anchor href=#%e7%99%bb%e5%bd%95%e5%8a%9f%e8%83%bd>#</a></h3><p>理解注册API后，登录也是一样的套路。</p><p>请求处理函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># publish/views.py</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@csrf_exempt</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>login</span>(request):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> request<span style=color:#f92672>.</span>method <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;POST&#39;</span>:
</span></span><span style=display:flex><span>        username <span style=color:#f92672>=</span> request<span style=color:#f92672>.</span>POST<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;username&#39;</span>)  <span style=color:#75715e># 获取请求数据</span>
</span></span><span style=display:flex><span>        password <span style=color:#f92672>=</span> request<span style=color:#f92672>.</span>POST<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;password&#39;</span>)
</span></span><span style=display:flex><span>        author <span style=color:#f92672>=</span> Author<span style=color:#f92672>.</span>objects<span style=color:#f92672>.</span>get(username<span style=color:#f92672>=</span>username)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> author<span style=color:#f92672>.</span>password <span style=color:#f92672>==</span> password:  <span style=color:#75715e># 判断请求的密码是否与数据库存储的密码相同</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># 密码正确则将用户名存储于session（django用于存储登录信息的数据库位置）</span>
</span></span><span style=display:flex><span>            request<span style=color:#f92672>.</span>session[<span style=color:#e6db74>&#39;username&#39;</span>] <span style=color:#f92672>=</span> username
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> JsonResponse({<span style=color:#e6db74>&#39;errno&#39;</span>: <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;msg&#39;</span>: <span style=color:#e6db74>&#34;登录成功&#34;</span>})
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> JsonResponse({<span style=color:#e6db74>&#39;errno&#39;</span>: <span style=color:#ae81ff>1002</span>, <span style=color:#e6db74>&#39;msg&#39;</span>: <span style=color:#e6db74>&#34;密码错误&#34;</span>})
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> JsonResponse({<span style=color:#e6db74>&#39;errno&#39;</span>: <span style=color:#ae81ff>1001</span>, <span style=color:#e6db74>&#39;msg&#39;</span>: <span style=color:#e6db74>&#34;请求方式错误&#34;</span>})
</span></span></code></pre></div><p>存储登录信息其实在前后端分离的架构中并不常用，因为前后端分离后Django内带的的session和cookie会失效，解决方法我们刚才也提到过，采用 JWT 即可解决，我们只需要在签放的令牌（token）中记录用户信息，就可以达到和session还有cookie的效果，而且更安全</p><details><summary>Django session 存储登录信息</summary><div class=markdown-inner><p><strong>session</strong>：临时保存在服务器端的用户数据，本质是键值对。将用户登录时的ID（标志）存储在 session 中以便后续获取，当处理修改用户信息等请求时，从中获取并核验身份，防止用户能修改其它用户的信息。</p><p>登录时：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 如果登录成功，存储用户标志信息</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> user<span style=color:#f92672>.</span>password <span style=color:#f92672>==</span> password: 
</span></span><span style=display:flex><span>    request<span style=color:#f92672>.</span>session[<span style=color:#e6db74>&#39;id&#39;</span>] <span style=color:#f92672>=</span> user<span style=color:#f92672>.</span>id
</span></span></code></pre></div><p>检查登录信息时，需要获取 session 存储的数据：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>username <span style=color:#f92672>=</span> request<span style=color:#f92672>.</span>POST<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;username&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> request<span style=color:#f92672>.</span>session<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#39;username&#39;</span>) <span style=color:#f92672>==</span> username:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 若session存储数据和请求的用户名相同，则登录信息核验成功</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 防止用户能修改其它用户的信息</span>
</span></span></code></pre></div></div></details><p>添加路由：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># publish/urls.py</span>
</span></span><span style=display:flex><span>urlpatterns <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    path(<span style=color:#e6db74>&#39;register&#39;</span>, register),  <span style=color:#75715e># 指定register函数的路由为register</span>
</span></span><span style=display:flex><span>    path(<span style=color:#e6db74>&#39;login&#39;</span>, login)
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><h3 id=退出登录功能>退出登录功能
<a class=anchor href=#%e9%80%80%e5%87%ba%e7%99%bb%e5%bd%95%e5%8a%9f%e8%83%bd>#</a></h3><p>处理函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#a6e22e>@csrf_exempt</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>logout</span>(request):
</span></span><span style=display:flex><span>    request<span style=color:#f92672>.</span>session<span style=color:#f92672>.</span>flush()	<span style=color:#75715e># 如果前后端分离采用JWT则不需要这一步，甚至退出登录不需要后端来完成</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> JsonResponse({<span style=color:#e6db74>&#39;errno&#39;</span>: <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#39;msg&#39;</span>: <span style=color:#e6db74>&#34;注销成功&#34;</span>})
</span></span></code></pre></div><p>指定路由：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>urlpatterns <span style=color:#f92672>=</span> [
</span></span><span style=display:flex><span>    path(<span style=color:#e6db74>&#39;register&#39;</span>, register),  <span style=color:#75715e># 指定register函数的路由为register</span>
</span></span><span style=display:flex><span>    path(<span style=color:#e6db74>&#39;login&#39;</span>, login),
</span></span><span style=display:flex><span>    path(<span style=color:#e6db74>&#39;logout&#39;</span>, logout)
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><h2 id=sqlite-数据库可视化>sqlite 数据库可视化
<a class=anchor href=#sqlite-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8f%af%e8%a7%86%e5%8c%96>#</a></h2><h3 id=pycharm-可视化数据库>Pycharm 可视化数据库
<a class=anchor href=#pycharm-%e5%8f%af%e8%a7%86%e5%8c%96%e6%95%b0%e6%8d%ae%e5%ba%93>#</a></h3><p>这里只展示 Pycharm 如何可视化 <code>db.sqlite3</code> 文件。</p><p>在 Pycharm 右侧侧边栏处，点击 Database 按钮，添加 Data Source：</p><p><img src=/SE-Labs/images/lab2/sqlite1.png alt=sqlite1></p><p>在弹出的选项框中，选择项目根目录的 sqlite3 文件；若提示缺失驱动，点击下载并测试连接，成功后点击确认即可：</p><p><img src=/SE-Labs/images/lab2/sqlite2.png alt=sqlite2></p><p>若未显示数据库，请按下图操作：</p><p><img src=/SE-Labs/images/lab2/sqlite3.png alt=sqlite3></p><h3 id=datagrip-可视化数据库>DataGrip 可视化数据库
<a class=anchor href=#datagrip-%e5%8f%af%e8%a7%86%e5%8c%96%e6%95%b0%e6%8d%ae%e5%ba%93>#</a></h3><p>我们还可以采用 DataGrip 进行数据库可视化，该软件其实也是 JB 旗下的一个软件（Pycharm 也是 JB 旗下的），因此其可视化效果和连接数据库的方式与上述的 Pycharm 的可视化差不太多。具体 DataGrip 的下载还有连接数据库可以参考如下连接：</p><ul><li>安装 DataGrip:
<a href=https://super-buaa-2021.github.io/Djangobook/post/ch1/4.html>Datagrip 基本使用 · Django Book</a></li><li>使用 DataGrip：
<a href=https://super-buaa-2021.github.io/Djangobook/post/ch1/5.html>应用创建与数据库初始化 · Django Book</a></li></ul><h3 id=使用-mysql>使用 MySQL
<a class=anchor href=#%e4%bd%bf%e7%94%a8-mysql>#</a></h3><p>但是实际上如果我们的网站打算部署在云端大家都可以通过公网IP进行访问（<strong>软工一不要求项目进行部署</strong>），我们更多的还是采用自己的<strong>云数据库</strong>，那么如何使用云数据库（以MySQL为例）呢 ？</p><p>首先我们得需要一个云数据库，这个云数据库可以安装在自己的具有公网IP的服务器内（网上有大量教程教大家如何在自己的服务器中安装云数据库），也可以自行购买云数据库，个人推荐后者。</p><p>下面介绍如何自行购买云数据库，如果已经有云数据库的同学可以跳过这个部分</p><h2 id=postman-测试>Postman 测试
<a class=anchor href=#postman-%e6%b5%8b%e8%af%95>#</a></h2><p>前后端分离开发中，仅后端一般无法通过点击图形化界面进行测试，后端的测试也不应该依赖于前端，而应该独立进行。因此后端的测试，需要借助工具模拟前端请求，向后端相应的路由发送请求，并查看响应数据。</p><p><a href=https://www.postman.com/ target=_blank>Postman</a> 和 <a href=https://www.apifox.com/ target=_blank>Apifox</a> 就是这样的工具，下面以 Postman 举例。</p><p>Postman 下载地址：<a href=https://www.postman.com/ target=_blank>
<a href=https://www.postman.com/>https://www.postman.com/</a></a></p><p>注册账号，下载后登录 Postman，点击客户端左上角 Workspaces 组件，可为你的项目创建一个工作区，如果你对保存请求信息不感冒，使用默认 My Workspace 也可以。Postman 仅仅是测试的工具，因此这里也不多介绍管理文件夹存储请求记录这些东西了。</p><p>下面示例测试注册接口：</p><p><img src=/SE-Labs/images/lab2/postman.png alt=postman></p><p>可以看到返回数据是 JSON 格式，且提示注册成功。</p><p>上面我们采用了 Postman 作为实例的讲解了API接口测试工具，因为接口测试工具的使用方法都大同小异，无非就是编写测试样例然后模拟前端向后端发送求然后查看请求结果，但是软件工程的大项目是组队完成的，因此在这里推荐一款<strong>团队管理更方便而且是中文</strong>的接口测试工具 APIFOX</p><p>APIFOX 下载地址：<a href=https://www.apifox.com/ target=_blank>
<a href=https://www.apifox.com/>https://www.apifox.com/</a></a></p><p>在上面的红框（接口文档）可以编写接口文档，方便前后端交流沟通接口。下面的红框（快捷请求）和刚才讲解的 Postman 使用方式一致。</p><p><img src=/SE-Labs/images/lab2/apifox_1.png alt=postman></p><p>在下方快捷请求中，我们和Postman一样模拟发送请求，设置各种请求方式和数据，同时我们可以通过保存按钮自动生成接口文档</p><p><img src=/SE-Labs/images/lab2/apifox_2.png alt=postman></p><p>生成的接口文档的如下图所示，前端同学可以很清楚的知道后端的接口的含义是什么，测试样例是什么，返回结果是什么，前后端协作的效率翻倍！！</p><p><img src=/SE-Labs/images/lab2/apifox_3.png alt=postman></p><p>同样在环境切换上，Apifox也大大提高生产力，我们可以和 Postman 一样设置全局的参数，这样就可以大家一起享用一个变量（比如可以把一个用户的登录后的token令牌放到全局变量里面，这样的话大家都可以使用这个用户的信息了）。同时如果将来要部署我们的网站，可以设置不同的访问环境，这样可以快速切换本地的测试环境与部署的正式环境（通过图中的红色箭头的下拉栏切换），在不同的环境下发送请求</p><p><img src=/SE-Labs/images/lab2/apifox_4.png alt=postman></p><h2 id=简单的调试方法>简单的调试方法
<a class=anchor href=#%e7%ae%80%e5%8d%95%e7%9a%84%e8%b0%83%e8%af%95%e6%96%b9%e6%b3%95>#</a></h2><p>对后端来说，如果使用 Postman/Apifox 发送请求后结果和预料的正常结果不一致，但这时候我们只知道哪个函数出错了，难以缩小 bug 的范围并找出原因。</p><p>这里提供一个非常简单的小技巧，可以在 Python 出错的函数中，加上一些 <code>print</code> 输出，然后用 Postman 再次发请求，你可以在跑后端的终端中查看到你 print 的信息。</p><p>举个非常简单的例子，现在我查询文章列表出 bug 了，我想判断有没有进入循环，就可以在 <code>for</code> 循环内加入 <code>print(1)</code>，然后用 Postman/Apifox 再发一次请求，就能在跑后端的终端中看是否有 <code>1</code> 输出，没有则未进入循环。（万能的 <code>print</code> 法找 bug）</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/1cd1f95324ce45dc2bff7f20bfcef71bf36b55d4 title='Last modified by 暗中观察|.･｀) | March 14, 2023' target=_blank rel=noopener><img src=/SE-Labs/svg/calendar.svg class=book-icon alt=Calendar>
<span>March 14, 2023</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/docs/labs/lab02/django_door.md target=_blank rel=noopener><img src=/SE-Labs/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><script src=https://utteranc.es/client.js repo=BUAA-GoodBro2021/SE-Labs issue-term=pathname label=Comment theme=github-light crossorigin=anonymous async></script></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#django-入门篇快速入门立刻上手>Django 入门篇（快速入门，立刻上手！）</a><ul><li><a href=#环境配置>环境配置</a></li><li><a href=#新建项目>新建项目</a></li><li><a href=#了解项目结构>了解项目结构</a></li><li><a href=#项目预设置>项目预设置</a><ul><li><a href=#添加-app-信息>添加 APP 信息</a></li><li><a href=#路由分发>路由分发</a></li></ul></li><li><a href=#示例-出版网站>示例 出版网站</a><ul><li><a href=#数据库模型>数据库模型</a></li><li><a href=#注册功能>注册功能</a></li><li><a href=#登录功能>登录功能</a></li><li><a href=#退出登录功能>退出登录功能</a></li></ul></li><li><a href=#sqlite-数据库可视化>sqlite 数据库可视化</a><ul><li><a href=#pycharm-可视化数据库>Pycharm 可视化数据库</a></li><li><a href=#datagrip-可视化数据库>DataGrip 可视化数据库</a></li><li><a href=#使用-mysql>使用 MySQL</a></li></ul></li><li><a href=#postman-测试>Postman 测试</a></li><li><a href=#简单的调试方法>简单的调试方法</a></li></ul></li></ul></nav></div></aside></main></body></html>